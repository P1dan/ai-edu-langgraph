### 项目结构概览

**项目根目录**：`AI_Project/`

```
AI_Project/
├─ src/  # （你当前展示的内容没有单独 src，但你的 agent 模块就位于项目根下）
│
├─ agent/                  # 核心智能代理模块
│  ├─ __init__.py
│  ├─ basic_tool_node.py    # 一些基础工具节点
│  ├─ config.py             # 项目配置
│  ├─ graph.py              # 主状态图（LangGraph）
│  ├─ rag_tool.py           # RAG 相关工具
│  ├─ llm/                  # LLM 封装模块
│  │   └─ AliyunLLM.py
│  ├─ rag/                  # RAG 检索模块
│  │   ├─ rag_retriever.py
│  │   └─ vector_db.py
│  └─ learning_plan/        # 学习路径相关子模块
│      ├─ graph.py
│      ├─ nodes.py
│      └─ state.py
│
├─ data/                    # 存放文档、md 文件
│  └─ rag_data/
│      ├─ learning_plan.md
│      └─ 三角函数学习路径.md
│
├─ storage/                 # 存放向量数据库
│  └─ vector_db/
│      └─ trigonometry/
│          ├─ index.faiss   # FAISS 向量索引
│          └─ index.pkl
│
├─ 测试.py                  # 本地测试脚本
└─ agent.egg-info/          # Python 包信息
```

------

### 核心模块说明

1. **agent/**
   - `graph.py`：用 LangGraph 构建整个学习流程的状态图。
   - `llm/AliyunLLM.py`：封装阿里大模型调用接口。
   - `rag/rag_retriever.py`：RAG 检索器，用向量数据库检索相关知识。
   - `learning_plan/`：包含学习路径节点、状态定义、Graph 子模块。
2. **storage/vector_db/trigonometry/**
   - 存放 FAISS 向量索引及 pickle 文件，用于快速检索三角函数相关知识片段。
3. **data/rag_data/**
   - 存放输出文档，包括学习路径 Markdown 文件。

### 项目 Graph 模块概述

#### 1. Graph 的概念

在本项目中，Graph 是状态节点（Node）和节点之间的边（Edge）的组合，用于管理学习流程。  
每个节点对应一个功能步骤，如“澄清学习目标”、“检索知识”、“生成学习策略”、“生成最终学习路径文档”。  
通过边定义节点间的依赖顺序，LangGraph 会按照图结构自动执行整个流程。

---

#### 2. `graph.py` 的作用

在 `agent/learning_plan/graph.py` 中，定义了一个工厂函数：

```python
from agent.learning_plan.graph import build_learning_plan_graph

graph = build_learning_plan_graph()
build_learning_plan_graph() 返回一个 StateGraph 对象，已经配置好所有节点和边。

Graph 的核心职责：

管理学习流程的执行顺序

封装各个步骤的输入输出

提供统一接口 graph.invoke(state) 执行整个流程

3. 多 Graph 的使用
项目中可以定义多个 Graph，分别处理不同任务。例如：

from agent.learning_plan.graph import build_learning_plan_graph
from agent.other_task.graph import build_other_task_graph

learning_graph = build_learning_plan_graph()
other_graph = build_other_task_graph()
独立执行：每个 Graph 都是一个独立的状态机，可以独立调用：

result = learning_graph.invoke(user_input)
other_result = other_graph.invoke(other_input)
组合使用：一个 Graph 的输出可以作为另一个 Graph 的输入：

intermediate = learning_graph.invoke(user_input)
final_result = other_graph.invoke(intermediate)